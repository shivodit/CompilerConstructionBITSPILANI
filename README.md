# Compiler Construction BITS PILANI - CS F363

This is the term project for the CS F363 Compiler Construction course at BITS Pilani. The project implements a compiler front-end for a custom language. It consists of a lexical analyzer (lexer) and a syntax analyzer (parser) using an LL(1) parsing approach.

## Project Overview

### Lexical Analyzer (Lexer)
- **Purpose:** Converts source code into tokens.
- **Key Features:**
  - **DFA Implementation:** Uses a deterministic finite automaton with twin buffers for efficient file I/O.
  - **Tokenization:** Recognizes tokens such as identifiers, numbers (integer and real), keywords, and operators.
  - **Error Handling:** Reports invalid characters or patterns with line numbers.
  - **Symbol Table:** Manages reserved keywords and identifiers.
- **Main Files:**
  - `lexer.c`, `lexerDef.h`
  - `helper_function.c`, `helper_function.h`
  - `symbol_table.c`, `symbol_table.h`, `symbol_tableDef.h`

### Syntax Analyzer (Parser)
- **Purpose:** Checks syntactic correctness and builds a parse tree.
- **Key Features:**
  - **Grammar Reading:** Reads grammar rules from files (e.g., `final_grammar_index_clean.txt`).
  - **FIRST and FOLLOW Sets:** Computes these sets for all non-terminals.
  - **Parse Table Construction:** Builds an LL(1) parse table used to guide the parser.
  - **Predictive Parsing:** Uses a stack to match tokens against grammar rules and constructs a parse tree.
  - **Error Reporting:** Reports syntax errors with detailed messages.
- **Main Files:**
  - `parser.c`, `parser.h`, `parserDef.h`
  - `stack.c`, `stack.h`, `stackDef.h`
  - `parseTree.c`, `parseTree.h`, `parseTreeDef.h`

### Driver
- **Purpose:** Provides a menu-based interface to run the compiler.
- **Features:**
  - Remove comments from the source code.
  - Print the list of tokens generated by the lexer.
  - Parse the source code and print the parse tree.
  - Measure execution time for parsing.
- **Main File:** `driver.c`

### Test Harness (test.c)
- **Purpose:** A separate test program to verify the reading and display of FIRST and FOLLOW sets.
- **Usage:**  
  Compile using:
  ```bash
  gcc -Wall -Wextra -g -o test test.c -lm
  ```
  Run using:
  ```bash
  ./test
  ```
- **Output:** Displays each non-terminal with its corresponding FIRST and FOLLOW sets.

## Directory Structure

```
CompilerConstructionBITSPILANI/
├── driver.c
├── lexer.c
├── lexer.h
├── lexerDef.h
├── helper_function.c
├── helper_function.h
├── parser.c
├── parser.h
├── parserDef.h
├── parseTree.c
├── parseTree.h
├── parseTreeDef.h
├── stack.c
├── stack.h
├── stackDef.h
├── symbol_table.c
├── symbol_table.h
├── symbol_tableDef.h
├── test.c
├── final_grammar.txt
├── final_grammar_index_clean.txt
├── final_grammar_index_rep.txt
├── grammar_ex.txt
├── Makefile
├── README.md
└── testcases/
    ├── lexer_test_cases/
    │   ├── lexemesandtokens_t1.txt
    │   ├── lexemesandtokens_t2.txt
    │   ├── t1.txt
    │   └── t1_1.txt
    └── parser_test_cases/
        ├── t3.txt
        ├── t4.txt
        ├── t5.txt
        ├── t6.txt
```

## How to Build

1. **Compile the Main Compiler:**
   In the project root directory, run:
   ```bash
   make
   ```
   This will compile all source files into an executable named `compiler`.

2. **Compile the Test Harness:**
   To compile the test.c file (for FIRST/FOLLOW set testing), run:
   ```bash
   gcc -Wall -Wextra -g -o test test.c -lm
   ```

## How to Run

### Running the Compiler
The main executable requires two arguments:
```bash
./compiler <source_file> <parse_tree_output_file>
```
For example:
```bash
./compiler testcases/lexer_test_cases/t2.txt output_parse_tree.txt
```
A menu will appear with options:
- **0:** Exit.
- **1:** Remove comments (shows the cleaned file).
- **2:** Print token list.
- **3:** Parse the source code and generate a parse tree (saved to the output file).
- **4:** Display execution time for parsing.

### Running the Test Harness
To run the FIRST/FOLLOW set tester:
```bash
./test
```
This prints the FIRST and FOLLOW sets for each non-terminal to the console.

## Testing

Test cases are provided in the `testcases/` directory:
- **Lexer Test Cases:** Located in `testcases/lexer_test_cases/` to verify tokenization.
- **Parser Test Cases:** Located in `testcases/parser_test_cases/` for syntactically correct and incorrect inputs.

Run these test cases to validate both the lexical analyzer and parser.

## Known Issues and Future Work

- **Error Recovery:**  
  Current error handling in both lexer and parser prints errors and may continue. Enhanced recovery strategies are planned.
- **Corner Case Handling in Lexer:**  
  Some edge cases in floating-point number handling and retracting across buffers may need further refinement.
- **Semantic Analysis:**  
  This phase is not yet implemented but will be added in future stages.
- **Documentation:**  
  More detailed inline comments and function-level documentation will be added as development continues.

## Conclusion

This project implements a complete compiler front-end for a custom language, integrating a DFA-based lexer and an LL(1) predictive parser. The design is modular with clear separation of concerns, and it is accompanied by test cases and a dedicated test harness (test.c) for verifying grammar analysis. With further testing and refinement, this project will serve as a solid foundation for subsequent phases such as semantic analysis and code generation.

---

## Final Summary

- **Code Integration:**  
  The lexer reads the source file using twin buffers, tokenizes it using a DFA in `lexer.c`, and stores tokens in a symbol table.  
  The parser reads the grammar, computes FIRST and FOLLOW sets (using `ComputeFirstAndFollowSets()`), builds an LL(1) parse table, and parses the tokens into a parse tree using a stack.  
  The driver (`driver.c`) ties these components together and offers a menu for testing each phase.

- **Testing:**  
  Use the provided test cases (in the testcases folder) to verify both the lexer and parser.  
  Use `test.c` as an independent test program to check the FIRST/FOLLOW sets.

- **Building and Running:**  
  The Makefile builds the main executable (`compiler`). A separate compilation command is available for `test.c`.
